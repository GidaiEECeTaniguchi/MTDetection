Usable GUI Design: A Quick Guide for F/OSS Developers	使える GUI デザイン:フリー／オープンソース・ソフトウェア開発者のための手引き
Introduction	イントロダクション
The Open Source software world is full of excellent software.	オープンソース・ソフトウェアの世界は優れたソフトウェアでいっぱいです。
High-quality F/OSS software is available for virtually any task a computer user could want to do, from word-processing to web-serving.	ワードプロセッサから Web サービスにいたるまで、コンピュータでしたいと思うようなおおよそすべての作業において、高品質のフリー／オープンソース・ソフトウェアを利用することができます。
There is one small problem with much of this huge array of software:	しかしこうして勢ぞろいしたソフトウェアにも、ひとつ欠点があります。
it is often far more difficult to use than it could be.	あるべき使い勝手からかけ離れて使いにくいということがたびたびあるのです。
Professional UI designers tell us that user interfaces should be the first thing designed when we come to develop an application, and that programmers are incapable of doing this kind of design.	UI デザインの専門家は、アプリケーションの開発にあたっていちばんに設計されるべきなのはユーザー・インターフェースであるといいますが、プログラマにはこうした設計をすることができません。
They say it can only be done by the professional UI experts;	それは UI の専門家でなければできないことで、
OSS projects don't have access to these kind of people, and therefore can never be truly usable.	オープンソース・ソフトウェアのプロジェクトではこうした人々の手を借りることができず、それゆえ本当の使いやすさというものは望むべくもないというのです。
This doesn't mean we should just give up on UI design.	これは、わたしたちが UI デザインをあきらめるべきだということではありません。
From the quality of many commercial applications' UIs, having usability experts on staff doesn't guarantee a good interface either.	多くの商用アプリケーションの UI の品質を見ればわかるように、スタッフにユーザビリティのエキスパートを加えればそれで優れたユーザー・インターフェースが保証されるというわけでもないのです。
Effort, knowledge and thought by any developer can improve the usability of an application greatly.	開発者の努力、知識、洞察力がアプリケーションの使い勝手を大きく向上させることを可能にするのです。
We may only find a local optimum rather than the global, but even that is a step in the right direction.	わたしたちに見つけられるのは絶対的ではなくて近似的な解にすぎないかもしれませんが、それでもそれは正しい方向への進歩です。
After years of struggling with these problems, I thought I would write down a short list of five things that we OSS developers should consider when designing our application's GUI.	こうした問題に数年にわたって取り組んだ末に、わたしはオープンソース・ソフトウェア開発者がアプリケーションの GUI をデザインする際に守るべき 5 つの点について書くことにしました。
These are drawn from my experience in using and writing OSS software and my reading of a few very interesting books and web sites on the subject.	これらは、わたしがオープンソース・ソフトウェアを使用・開発した経験と、こうしたことがらについて扱っているいくつかのたいへん興味深い書籍や Web サイトから導き出したものです。
These works are listed in the references	それらの作品については参考文献に挙げてあります
――they are all excellent reading for any developer interested in usability issues.	――ユーザビリティの問題に興味がある開発者にとってはどれもすばらしい読みものです。
I have intentionally only mentioned points here which do not require major amounts of work to implement, and about which there is little controversy.	ほとんどの作品に必ずしも実装を要求されないことがらや、ちょっとした論争になっているようなことがらについては、わたしはあえて軽く触れるにとどめました。
Larger “whole-application” issues are beyond the scope of this article.	より広い「すべてのアプリケーション」についてが本稿の対象だからです。
None of these ideas is new or particularly complex, but their effect can be very great.	ここに挙げていることは新しいことでもなければ、これといって難しいことでもありませんが、その効果には目を見張るものがあります。
I should also note here that in several of the examples I use,	それから、わたしがここで取り上げる例についても述べておきます。
it is possible to fix the problem by changing the application's settings.	そのうちのいくつかについては、アプリケーションの設定を変えることで解決できるものもあります。
I have decided to only consider the default settings:	しかし、わたしはデフォルトの設定についてのみ考慮することにしました。
presumably, the defaults represent the developer's idea of the most usable design for their application.	デフォルトの状態こそが、そのアプリケーションにおけるもっとも使い勝手のよいデザインについての開発者の考えを表しているように思われるからです。
Before I start, I should probably make one more point in order to at least mitigate the flames I will receive:	はじめるに先立って、予想される罵倒にそなえてもう一点述べておくことにしましょう。
although I may sound quite harsh on some applications below, this is in no way meant as anything but constructive criticism.	アプリケーションによっては、以下に述べることがとりわけ手厳しいものに聞こえるかもしれませんが、これに建設的な批評以外の意図はありません。
I use most of these applications every day and they are fantastic pieces of work, the product of years of hard work by dedicated developers.	ほとんどのアプリケーションをわたしは毎日使っており、いずれも献身的な開発者たちの何年にもわたる努力の賜物、とびきりの名品ぞろいです。
I am merely making suggestions of potential improvements;	わたしはただ、さらなる改善の余地を提案しているだけで、
no offence is intended to anybody.	誰にたいする攻撃の意図もありません。
The Points	ポイント
0) The user is not using your application	0) ユーザーはアプリケーションを使うわけではない
The most basic point in all computer UI design is that the user does not want to use your application.	コンピュータの UI デザインにおけるもっとも基本的なポイントは、ユーザーはあなたのアプリケーションを使うために使っているわけではないということです。
They want to get their work done as quickly and easily as possible, and the application is simply a tool aiding that.	ユーザーは自分の作業をできるだけ手早く片付けたいと思っていて、アプリケーションはたんにその助けとなる道具であるにすぎません。
The more you can keep your application out of the way of the user, the better.	ユーザーをできるだけ早く解放してあげるアプリケーションほどよいアプリケーションです。
Effort spent on using your application is effort not spent on the work the user is trying to do.	あなたのアプリケーションを使うことに費やされた努力というのは、ユーザーのやろうとしている作業を片付けることには貢献していない努力なのです。
Two key quotes from Alan Cooper's second book, About Face 2.0, summarise this very well:	Alan Cooper の 2 冊目の著作、「About Face 2.0」から、このことをうまく要約しているふたつを引用することにします。
“Imagine users as very intelligent but very busy”	「ユーザーは賢く、そして多忙であると考えよ」
“No matter how cool your interface is, less of it would be better”	「どんなにクールなインターフェースでも、それなしで済むに超したことはない」
Points 1 to 4 in this article are really just special cases of this rule.	本稿の残りの 4 点はこの原則の特別なケースであるというのにすぎません。
1) Fitt's Law	1) Fitt の法則
This is the most basic and well known of UI design laws.	Fitt の法則はもっとも基本的で有名な UI デザインの法則です。
It states that the larger and nearer to the mouse pointer an on-screen object is, the easier it is to click on.	それによれば、スクリーン上のオブジェクトが大きくてマウスポインタに近いほど、クリックしやすいと述べられています。
That's common sense, yet it is often completely ignored in UI design.	こんなことはあたりまえなのですが、それでも UI デザインではすっかり無視されてしまうことが少なくありません。
Figure 1: Firefox toolbar	図 1: Firefox のツールバー
Consider, for example, the default Firefox button bar (Figure 1).	たとえば、デフォルトの Firefox のボタンバー（図 1）を考えてみてください。
When web browsing, by far the most common button anyone hits is the Back button.	Web ブラウジングでは、他と比べて圧倒的に押すことの多いボタンは［戻る］ボタンです。
The Back button should therefore be the easiest to hit:	したがって［戻る］ボタンは押しやすくなくてはいけません。
that way, you minimise the effort required of the user to use your application, and allow them to concentrate on web browsing.	このようにアプリケーションを使うことに費やす労力を最小限にすることで、ユーザーが Web ブラウジングに集中できるようになるのです。
But in the button bar, all five buttons are the same size.	ところがこのボタンバーでは、5 つのボタンすべてが同じ大きさになっています。
Is the Stop button really as important as the Back button?	［中止］ボタンは本当に［戻る］ボタンと同じくらい重要なのでしょうか？
No, of course not.	もちろん違います。
A better design would be something like Figure 2.	よりよいデザインは図 2 のようなものになるでしょう。
This makes the Back button both easier to click on by Fitt's law, and also easier to distinguish from the other buttons.	ここでは［戻る］ボタンは Fitt の法則にしたがって大きく、そして他のボタンよりも目立つものになっています。
Figure 2: An alternative design	図 2: 代替デザイン案
The apparent size of a control can be enlarged by placing it at a screen edge.	コントロールの外見上の大きさは、それをスクリーンの端に配置することで大きくすることができます。
When the mouse cursor hits the edge of the screen, it stops at exactly the screen edge, irrespective of how fast the mouse is moving.	マウスカーソルはスクリーンの端にまで達すると、どんなに早くマウスを動かしていたとしても、そこでマウスカーソルの動きは止まります。
This means that for the mouse user objects at the screen edge extend effectively an infinite distance off the screen.	このことは、マウスの使用者にとってはスクリーンの端にあるものは、スクリーンの外側に無限に広がっていることになるということを意味します。
A one pixel target in the top-right corner of the screen would be trivially easy to hit;	スクリーンの右上にある 1 ピクセルのターゲットにマウスカーソルを合わせるのは簡単なことです。
you would just have to ‘throw’ the mouse up and right as far as you liked.	マウスを右上に適当に「投げて」やればいいからです。
Move that one pixel to the middle of the screen, and hitting it would take you much longer.	スクリーンの中ほどにある 1 ピクセルにマウスカーソルを合わせてそれを押すのにはそれよりも時間がかかることでしょう。
From this we can see that controls that we want to be easy to hit should be positioned at the edges or corners of the screen.	このことから、押しやすくあってほしいコントロールは、スクリーン端に配置されるべきだということがわかります。
Figure 3: Metacity window decorations.	図 3: Metacity ウィンドウの装飾。
Note the inactive border around the buttons.	ボタンの周辺に無効な領域がある。
The simplest example of this is the window management buttons on all windows (close, maximise etc.).	もっとも簡単な例は、すべてのウィンドウに付いている（［閉じる］［最大化］などの）ウィンドウ操作用のボタンです。
These need to be easy to hit, so that controlling windows isn't fiddly.	ウィンドウを操作しやすくするために、これらは押しやすくなっている必要があります。
From their position at the top corners of all applications, these are prime candidates for moving to the corners.	全アプリケーションの上隅にあるわけですから、これらは角に置く筆頭候補です。
Yet very few window managers do this:	しかしながらそれを実践しているウィンドウ・マネージャはごくわずかです。
most Metacity themes don't, XFCE4 doesn't.	ほとんどの Metacity テーマがやっていませんし、XFCE4 もやっていません。
All it takes is to move the buttons one pixel up and right and the user can close windows without even having to look.	ボタンを 1 ピクセル右上に移動させるだけで、ユーザーは目をつむってでもウィンドウを閉じることができるようになるというのにです。
Figure 4: Scrollbar	図 4: スクロールバー
one pixel gap.	1 ピクセルのギャップ。
Another example is scroll bars.	もうひとつの例はスクロールバーです。
Most applications on my desktop put the right hand edge of the scroll bar one pixel away from the edge of the screen when maximised, shrinking the slider from the potential easy to hit infinite box to the right of the screen to a tiny 10-pixel wide box that takes an extra few seconds to click on every time I want to scroll.	わたしのデスクトップにあるほとんどのアプリケーションは、最大化したときにその右端から1 ピクセル離れたところにスクロールバーが付くようになっており、そうなっているばっかりにせっかくのポイントしやすい幅無限大のボックスは 10 ピクセルの小さなボックスへと縮められてしまっていて、わたしはスクロールしたいと思うたびにそこをクリックするのに余計な数秒を費やすことになってしまいます。
To summarise this point then:	このことをまとめると以下のようになります。
Make commonly used controls larger and distinctive	よく使われるコントロールは大きく、目立つようにする。
Use the edges and corners of the screen to make your controls virtually infinite	スクリーンの端と四隅に配置されるコントロールは事実上無限に広がっているとみなすことができる。
Never, ever put controls 1 pixel away from a screen edge or corner	スクリーンの端や四隅から 1 ピクセル離れてコントロールを置くようなことはしない。
2) Unnecessary interference	2) 不必要なインターフェース
When a user is working, their attention is on the work they are doing.	ユーザーが作業をしているときには、かれらの注意は行っている作業のことにあります。
Every time they have to move their attention away from their work to the application, it takes time for them to get back to where they were in their work.	ユーザーがアプリケーションへと注意を向けるそのたびごとに、かられが作業に集中しなおすだけの時間が失われていきます。
Therefore, you should minimise the amount of distraction and interference your application gives the user.	したがって、アプリケーションがユーザーの気を散らせたり邪魔をしたりするようなことは最小限にとどめなければなりません。
Every application has an item that is its key focus	アプリケーションにはそれが対象としているアイテムというものが存在しています
――in a text editor, it's the text;	――テキストエディタならテキスト、
in a web browser, it's the web page	Web ブラウザなら Web ページです。
――so make that central to your interface.	インターフェースはそれが中心になるように作らなければいけません。
An example for this is confirmation and progress dialogs.	このことの例としては、確認や進行状況のダイアログが挙げられます。
Evolution, for example, pops up a dialog box every time I click “Send/Receive” to inform me of its progress in checking my mail.	たとえば、Evolution はわたしが［送受信］ボタンを押すたびにダイアログをポップアップしてメールをチェックしているその進行状況を教えます。
This dialog is right in the way of the mail being received and blocks access to the rest of the application.	このダイアログはメールを受信したので、ほかのアプリケーションへのアクセスをブロックしようという場合であればまっとうだといえます。
What purpose does this dialog serve?	しかしこのダイアログの提供しているものはなんでしょう？
All it does is get in the way of the user.	これはたんにユーザーの邪魔をするのにしか役に立っていません。
It would be far better eliminated and replaced with a status bar progress meter.	このダイアログは廃止して、ステータスバーの進捗メーターに置き換えたほうがずっとよいでしょう。
Figure 5: Find dialog in gEdit	図 5: gEdit の検索ダイアログ
A worse example is KDE's default Trashcan behaviour.	さらに悪い例は KDE のごみ箱のデフォルトでの振る舞いです。
Sending a file to the Trash is an easily reversible action that the user might want to do several times in a row:	ファイルをごみ箱に送るのは、簡単に復元でき、またユーザーが繰り返し行うこともある操作です。
why force users to click “OK” every time, when the action can be easily undone.	どうして簡単にやり直せる作業でユーザーに［OK］を毎回クリックするのを強制するのでしょうか。
If you want to alert the user to the fact that a file has been sent to the trash, play some sort of animation.	ユーザーにファイルがごみ箱に送られたということを警告したいのであれば、アニメーションのようなものを表示させればいいのです。
Don't put a road block in their way every time they do such a simple action.	こうした簡単な操作において毎回ユーザーの邪魔をしてはいけません。
All that does is annoy users, slow them down and condition them to blindly click OK on dialogs.	そんなことはユーザーをうるさがらせて作業を遅滞させ、ダイアログでやみくもに［OK］を押すよくない習慣を付けさせることにしかつながりません。
Another example is the omnipresent “Text not found” dialog in the search facility of text editors.	別の例はテキストエディタの検索機能でおなじみの「見つかりません」ダイアログです。
If the text I entered in the search dialog hasn't been found, it's most likely that I typed the search string wrong and now want to edit it and repeat the search.	検索ダイアログに入力した文字列が見つからなかったとすれば、おそらくは検索する文字列が間違っていたわけで、それなら検索文字列を修正して検索を続けようとするのが普通です。
But there's now a dialog box with an “OK” button in the way, so I have to click that away before I can do anything.	しかしそこには［OK］ボタンのついたダイアログボックスが立ちはだかっており、なにをするにもまずはそいつをクリックしてのけなければならないのです。
More annoyance and work on the part of the user.	ユーザーにはさらなる苛立ちと手間がかさみます。
A better example is Firefox's find dialog,	よい例としては Firefox の検索ダイアログが挙げられます。
which turns red when the search term isn't found.	これは検索語が見つからないときには赤く色が付くのです。
Figure 6: Contrary to all the evidence, there are no monkeys on Slashdot	図 6: あらゆる証拠に反して、Slashdot には monkey は見あたらない。
To summarise this point:	このことをまとめると:
Don't put road blocks in the way of your users	ユーザーの通り道につまずくような石を置かない。
Only pop up a dialog if it contains useful information	ポップアップダイアログは役に立つ情報を含んでいる場合にのみ使う。
If at all possible, use non-modal status indicators	できるだけ非モーダルなステータス表示をする。
3) Use the power of the computer	3) コンピュータのパワーを使え
Computers are powerful things these days, with billions of processor cycles per second and hundreds of gigabytes of storage available.	コンピュータは昨今、1 秒間に何十億回もの演算をこなし、何百ギガバイトものストレージを使うことのできる、パワフルなものとなりました。
Humans, however, haven't changed that much in hundreds of years.	かたや人間はといえば、何百年たってもそれほど変わっていません。
We still get tired, bored or distracted and have a limited amount of mental energy available at any one time.	わたしたちはいまだに疲れやすく、すぐ飽きるし、間違えるし、一度に限られた精神力しか発揮することができません。
It would seem a good idea, therefore, to shift as much work as possible off the poor, worn out human and on to the untiring, super fast computer in front of them.	したがって、できるだけ多くの作業を、みすぼらしく擦り切れた人間などではなく、疲れ知らずでメチャ速の、目の前のコンピュータに任せるようにしたほうが賢明であるように思われるのです。
In user interface design, the implication of this idea is clear:	ユーザー・インターフェースにおいて、このアイデアの示唆するところは明白です。
every time there is a decision to be made or work to be done, try to make the interface do it for the user.	決定しなければならないことや、やらなければならないことがあるたびに、インターフェースがユーザーのためにそれをやってくれるようにできないか考えてみてください。
For example, in my task bar at the moment I have two xterms open (Figure 7).	たとえば、わたしのタスクバーには現在ふたつの xterm が開いています（図 7）。
One is open in the directory of the SiEd source code, the other in the directory of the LaTeX code for a research paper.	ひとつは SiEd のソースコードのあるディレクトリを開いており、もうひとつは論文の LaTeX コードがあるディレクトリを開いています。
Can you tell which is which?	どっちがどっちだかわかりますか？
I can't,	わかりませんよね。
so in order to select the correct one I have to do work, either by clicking on the taskbar or hovering over it and using the tooltips.	そこでわたしは自分の作業したいほうを選ぶのに、タスクバーをクリックしたり、そこにマウスカーソルをもっていってツールチップを表示させたりすることになるわけです。
But the computer knows which is which:	しかしコンピュータはどっちがどっちなのか知っているのです。
why can't it do that work for me?	どうしてそれをわたしのためにやってくれないのでしょうか？
Figure 7: GNOME's taskbar being unhelpful	図 7: GNOME のタスクバーは不親切だ。
The solution is simple:	解決策は単純です。
for the entries of identical applications in the taskbar, look at the task names and display sufficient information to distinguish them.	タスクバーにある同一のアプリケーションについては、タスク名を見て、それらを区別できるような情報を表示するようにすればよいのです。
That way, I can quickly select between many different applications with little thought.	そうすれば、わたしは多くの異なるアプリケーションをほとんど考えることなく切り替えることができます。
The computer does the work so I don't have too.	コンピュータがその作業をやってくれるので、わたしはそれをしなくてすむわけです。
If computers have so much storage space available, why do so many applications forget my settings every time I exit them?	もしコンピュータがそれほどまでに広大なストレージを利用できるというのであれば、終了させるたびにわたしの設定を忘れてしまうアプリケーションが多いのはどうしてなのでしょう？
For example, I never use the Anjuta IDE in anything but a maximised window.	わたしは Anjuta IDE は必ず最大化させて使うのですが、
Anjuta defaults to an window almost as large as my screen when opened, with the top left corner about three pixels from the corner of the screen.	Anjuta は起動させるとわたしの使っているスクリーンと同じくらいの大きさでウィンドウを初期化し、ウィンドウの左上をスクリーンから 3 ピクセル離れたところにもっていきます。
So I click maximise, do some development and exit.	そこでわたしはウィンドウを最大化させ、なにか開発をして、終了させます。
Next time I open Anjuta, it has reverted to an unmaximised window again.	次回 Anjuta を起動させると、それはまたもや最大化されていない状態に逆戻りです。
So I am forced to stop what I'm doing and click maximise every time I start the program.	そこでわたしは、やろうとしていたことについて考えるのを中断して、このプログラムを起動するたびに毎回最大化ボタンをクリックするのです。
Storing the previous window size, position and state would take maybe 20 bytes of storage,	以前のウィンドウのサイズや場所、状態を記憶しておくのにはストレージの 20 バイトもあれば足りるでしょう。
a small price to pay for saving thousands of clicks.	何千回のクリックに比べれば安いものです。
The Nautilus file manager in GNOME gets this right:	GNOME の Nautilus ファイルマネージャはこの点申し分ありません。
everything from the window size to the scrollbar position is remembered for every window, so once I set up a directory window the way I want it, I never have to worry about it again.	ウィンドウのサイズからスクロールバーの位置に至るまで、すべてがウィンドウごとに記憶されており、一度ディレクトリのウィンドウを好みに設定しておけばもうそのことで頭を悩ませることはありません。
To summarise this point:	以上をまとめると以下のようになります:
The computer is powerful:	コンピュータはパワフルだ:
use the computer's power to help the user	コンピュータのパワーでユーザーを助けよう。
Make similar items easy to distinguish between	似ているアイテムを区別しやすくしてあげよう。
Remember application settings	アプリケーションの設定は記憶する。
4) Make items easy to distinguish and find	4) アイテムは区別しやすく見つけやすく
This point is pretty simple:	このポイントはきわめてシンプルです。
items on the screen that do different things should be easy to see and differentiate from each other.	異なることをするスクリーン上のアイテムは見やすくそしてお互いに異なって見えるべきだということです。
For an extreme example of attempting to make actions easily accessible and failing, look at Konqueror's default taskbar:	操作をしやすくしようと目論んで失敗している端的な例として、Konqueror のデフォルトのタスクバーをご覧ください。
Figure 8: Konqueror's default toolbar	図 8: Konqueror のデフォルトのツールバー
The left hand item is the up-arrow, possibly the least used command in the web browser.	左端のアイテムは上向きの矢印になっていて、Web ブラウザの中ではもっとも使用頻度の少ないコマンドが割り当てられています。
The left hand position is the easiest to find and click on, so the most commonly used action should go there.	左端というのはもっとも見つけやすくクリックしやすい場所ですから、もっともよく使われる操作がここにこなくてはいけません。
Every other browser I know of correctly puts the Back button on the left for this reason.	わたしの知っている他のすべてのブラウザが［戻る］ボタンを左端に置いているのはそれが理由です。
The Find button and the two zoom buttons are very similar;	検索ボタンとふたつのズームボタンはとても似通っています。
the Forward, Back, Up, Home and Refresh buttons are all the same colour,	［進む］［戻る］［上へ］［ホーム］そして［更新］ボタンはすべて同じ色をしています。
making quick identification of them more difficult.	すばやくこれらを見分けるのは至難の業です。
But most importantly, there are fifteen of them!	さらに重要なことは、それらが 15 個も並んでいるということです！
Humans are very good at distinguishing between around five items:	人間は 5 つ前後のアイテムを識別するのは得意で、
we can do it instantly, with no thought.	それくらいであれば考え込まずに即座にすることができます。
That's the main reason that sheet music has five lines on the stave.	楽譜の譜面が 5 行からなっているのもそれが主な理由です。
More than five items and we have to stop and use brain power to figure out which item is which.	5 つを超えると、わたしたちは立ち止まって脳を使ってどれがどれであるかを考えなければならなくなります。
A much better design would only put the most commonly used items on the toolbar, minimising the work the user has to do in the common case.	優れたデザインでは、ツールバーにはもっともよく使われるアイテムのみが配置され、一般的にユーザーがしなければならないことを最小限に絞っています。
Many applications have this many items on the taskbar, but for a task as simple as browsing the web, fifteen is overkill.	多くのアプリケーションがこうしたたくさんのアイテムをタスクバーに並べていますが、Web をブラウズするといった単純なタスクの場合は、15 個というのはやりすぎです。
I have watched new users try to use Konqueror and seen first hand how much this layout confuses them;	わたしは新規のユーザーが Konqueror を使おうとして、この配置がいかにかれら自身を混乱させるかを見てきました。
it confuses me, an experienced computer user.	経験を積んだコンピュータユーザーであるわたしでさえ混乱するのですから。
Another example of difficulty in distinguishing items can be found in the default GNOME theme.	アイテムの識別が困難になる別の例は、デフォルトの GNOME で見られます。
Look at the text selection in Figure 9.	図 9 の範囲選択されたテキストを見てください。
Figure 9: Text selection in GNOME Simple theme	図 9: GNOME Simple theme のテキスト選択
When the user selects text, his attention is on the selected text.	ユーザーがテキストを範囲選択したとき、彼の注意は選択したテキストにあります。
He has presumably selected it in order to do something with it.	ユーザーはおそらくそれをどうにかするために選択したのですから。
So why does this theme change the background of the selection to a dark colour, so that the hardest text to read on the screen is the very text the user is most focused on?	それなのにどうしてこのテーマでは選択範囲の背景を暗い色にして、ユーザーが注目しているまさにそのテキストをスクリーン上で読みにくくしてしまうのでしょうか？
Would it not be better to make this text stand out from the rest by making it brighter and easier to read?	その部分を明るくして他の部分から際立たせ、読みやすくしたほうがよいのではないでしょうか？
To summarise this point:	このことをまとめると以下のようになります:
Make items that do different things distinctive	異なることをするアイテムは区別しやすく
Don't overwhelm your user with choice	ユーザーを選択肢でおぼれさせない
Make the currently selected or focused item easy to distinguish and read	選択していたりフォーカスのあたっているアイテムは目立たせ、読みやすいようにする
These five points represent a small but important part of UI design.	以上の 5 つのポイントは些細なことですが、UI デザインの重要な部分を占めています。
They are not in any way commandments or miracle cures for UI problems.	これらは UI の問題についての、鉄の掟や特効薬といったものではありません。
Following their principles in designing an interface should, in my opinion, greatly improve the usability of an application.	これらの原則にしたがってインターフェースをデザインすることで、わたしの意見によれば、アプリケーションの使い勝手を大きく向上できるということです。
I would welcome any comments, corrections or additions	訂正や追加など、どんなコメントでも歓迎します
(email address below, remove the nospam).	（下記のメールアドレスへどうぞ、nospam の部分を取り除いてください）。
These ideas are only a brief summary:	これらのアイデアは簡単な要約にすぎません。
I would recommend anyone serious about interface design to look at the references listed below.	インターフェース・デザインについて真剣に取り組もうという方には、下記に挙げる参考資料に目を通されることをお勧めします。
Alan Cooper's book is excellent;	Alan Cooper の本はたいへんすばらしいものです。
Jef Raskin's is a very useful reference, with some interesting ideas for thinking outside the ‘standard’ range of interface design.	Jef Raskin のはひじょうに役に立つ資料で、「普通」のインターフェース・デザインから離れた興味深いアイデアが含まれています。
I have read many comments on this article and have written an FAQ responding to some of them	本稿についてたくさんのコメントをいただいたので、そのうちのいくつかに答えるべく、FAQ を書きました。
References	参考文献
About Face 2.0: The Essentials of Interaction Design, Alan Cooper and Robert Reimann, 2003, Wiley The Humane Interface, Jef Raskin, 2000, Addison-Wesley Professional The Interface Hall of Shame Apple Human Interface Guidelines KDE Human Interface Guidelines GNOME Human Interface Guidelines	（邦訳: ジェフ・ラスキン、『ヒューメイン・インタフェース――人に優しいシステムへの新たな指針』、ピアソンエデュケーション、2001 年）
Changelog	更新履歴（オリジナル）
2004-11-19 : Replaced OpenOffice maximisation state example with Anjuta example after fixing my OpenOffice install and realising it did remember state after all	2004-11-19: 再インストールしたらなんだか状態を覚えてくれるようになったので、OpenOffice の最大化の例を Anjuta の例に変更。
2004-11-21 : Added links to KDE and GNOME HIGs	2004-11-21: KDE と GNOME HIGs へのリンクを追加。
2004-11-21 : Added link to FAQ	2004-11-21: FAQ へのリンクを追加。
About the author	著者について
I'm a Free Software advocate and the main developer of SiEd, a GPL-licensed text editor for Palm OS devices.	わたしはフリーソフトウェアの擁護者で、GPL ライセンスの Palm OS デバイス向けテキストエディタ、SiEd のメイン・デベロッパーです。
In my real life, I am doing a PhD in Process Scheduling at the Centre for Process Systems Engineering, Imperial College.	実生活では、インペリアル・カレッジのプロセスシステム工学科で Process Scheduling の PhD をしています。
